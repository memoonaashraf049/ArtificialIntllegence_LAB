# -*- coding: utf-8 -*-
"""A*ResultRep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MvK2hLk5m-CvBclBEC0-O0b6NUEIpyTg

## A* Algorithm ***bold text***
"""

import heapq                    # Import heapq to use a priority queue (min-heap)

#  Weighted graph: each node maps to a dict of neighbors and edge costs (distances)
graph = {
    "CityA": {"CityB": 250, "CityC": 170}, # Changed city names here
    "CityB": {"CityA": 250, "CityD": 180}, # Changed city names here
    "CityC": {"CityA": 170, "CityE": 210}, # Changed city names here
    "CityE": {"CityC": 210, "CityF": 850}, # Changed city names here
    "CityD": {"CityB": 180}, # Changed city names here
    "CityF": {"CityE": 850} # Changed city names here
}
# Heuristic must be admissible (never overestimate) to guarantee optimality.
heuristic = {
    "CityA": 1210, # Changed city names here
    "CityB": 1100, # Changed city names here
    "CityC": 1050, # Changed city names here
    "CityE": 880, # Changed city names here
    "CityD": 1250, # Changed city names here
    "CityF": 0 # Changed city names here
}
def a_star(graph, start, goal, heuristic):
    """
    A* search returns (path, total_cost) or (None, inf) if no path found.
    We store paths in the priority queue together with their f-cost = g + h.
    """
    open_list = []  # priority queue (min-heap) storing tuples (f_cost, path_list)
    #  push the start node. g(start)=0 so f = 0 + h(start) = h(start)
    heapq.heappush(open_list, (heuristic[start], [start]))
    g_costs = {start: 0}  #  dictionary to store best-known g(n) costs
    closed_set = set()    #  nodes whose best cost is finalized

    #  loop until there are no nodes left to expand
    while open_list:
        f, path = heapq.heappop(open_list)  # pop node with smallest f(n)
        node = path[-1]                     # current node is the last in the path

        #  goal test
        if node == goal:
            return path, g_costs[node]

        # skip if we already finalized this node
        if node in closed_set:
            continue

        closed_set.add(node)  #  mark node as finalized

        # iterate through neighbors and edge costs
        for neighbor, cost in graph[node].items():
            tentative_g = g_costs[node] + cost  # g through current node to neighbor

            # if neighbor unseen or we found a cheaper g, update
            if neighbor not in g_costs or tentative_g < g_costs[neighbor]:
                g_costs[neighbor] = tentative_g
                f_cost = tentative_g + heuristic.get(neighbor, float('inf'))
                new_path = path + [neighbor]
                heapq.heappush(open_list, (f_cost, new_path))

    # if open_list empties without reaching goal => no path
    return None, float('inf')

# Example run
if __name__ == "__main__":
    start_city = "CityA" # Changed city names here
    goal_city = "CityF" # Changed city names here
    path, cost = a_star(graph, start_city, goal_city, heuristic)
    print("A* path:", path)
    print("Total cost:", cost)