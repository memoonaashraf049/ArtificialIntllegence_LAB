# -*- coding: utf-8 -*-
"""MidLab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13lOg_bm-aEHcrp9zyXRmQ3WiX6u8yFeM

**MID LAB**
"""

from collections import deque
import heapq

# --- Helper Functions ---

def is_valid_state(m_left, c_left):
    """Check if a state is valid (no missionaries eaten)."""
    m_right, c_right = 3 - m_left, 3 - c_left
    if (m_left < 0 or c_left < 0 or m_right < 0 or c_right < 0):
        return False
    if (m_left > 0 and c_left > m_left):  # Left side invalid
        return False
    if (m_right > 0 and c_right > m_right):  # Right side invalid
        return False
    return True


def get_successors(state):
    """Generate all valid next states from the current one."""
    m_left, c_left, boat = state
    successors = []
    moves = [(1, 0), (2, 0), (0, 1), (0, 2), (1, 1)]

    for m, c in moves:
        if boat == 'L':  # Boat goes to right
            new_state = (m_left - m, c_left - c, 'R')
        else:             # Boat goes to left
            new_state = (m_left + m, c_left + c, 'L')

        if is_valid_state(new_state[0], new_state[1]):
            successors.append(new_state)

    return successors


def print_path(path):
    for i, state in enumerate(path):
        print(f"Step {i}: {state}")
    print("âœ… Goal reached!\n")


# --- Breadth-First Search (BFS) ---

def bfs(start_state):
    queue = deque([[start_state]])
    visited = set([start_state])

    while queue:
        path = queue.popleft()
        state = path[-1]

        if state == (0, 0, 'R'):
            print("BFS Solution Path:")
            print_path(path)
            return path

        for succ in get_successors(state):
            if succ not in visited:
                visited.add(succ)
                queue.append(path + [succ])

    print("No solution found with BFS.")
    return None


# --- Depth-First Search (DFS) ---

def dfs(start_state):
    stack = [[start_state]]
    visited = set([start_state])

    while stack:
        path = stack.pop()
        state = path[-1]

        if state == (0, 0, 'R'):
            print("DFS Solution Path:")
            print_path(path)
            return path

        for succ in get_successors(state):
            if succ not in visited:
                visited.add(succ)
                stack.append(path + [succ])

    print("No solution found with DFS.")
    return None


# --- A* Search Algorithm ---

def heuristic(state):
    """Heuristic: number of people remaining on the left / 2."""
    m_left, c_left, _ = state
    return (m_left + c_left) // 2

def astar(start_state):
    pq = []
    heapq.heappush(pq, (0 + heuristic(start_state), 0, [start_state]))
    visited = set([start_state])

    while pq:
        f, g, path = heapq.heappop(pq)
        state = path[-1]

        if state == (0, 0, 'R'):
            print("A* Solution Path:")
            print_path(path)
            return path

        for succ in get_successors(state):
            if succ not in visited:
                visited.add(succ)
                g_new = g + 1
                f_new = g_new + heuristic(succ)
                heapq.heappush(pq, (f_new, g_new, path + [succ]))

    print("No solution found with A*.")
    return None


# --- Main Execution ---

if __name__ == "__main__":
    start = (3, 3, 'L')
    bfs(start)
    dfs(start)
    astar(start)